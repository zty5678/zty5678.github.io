<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¡¨æƒ…åŒ…æ™ºèƒ½è£å‰ªå·¥å…· - æŠ–éŸ³å°çº¢ä¹¦ä¸“ç”¨</title>
  <!-- å¼•å…¥ Cropper.js åº“ -->
  <link rel="stylesheet" href="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.css">
  <script src="https://unpkg.com/cropperjs@1.5.13/dist/cropper.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
      padding: 20px;
    }
    
    .container {
      max-width: 960px;
      margin: 0 auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 15px;
      color: #333;
      font-size: 28px;
    }
    
    .description {
      text-align: center;
      margin-bottom: 25px;
      padding: 15px;
      background-color: #f8f9ff;
      border-radius: 8px;
      border-left: 4px solid #4a6cf7;
    }
    
    .description p {
      margin: 8px 0;
      color: #555;
      font-size: 16px;
      line-height: 1.5;
    }
    
    .description p:first-child {
      font-weight: 600;
      color: #4a6cf7;
    }
    
    .description .tips {
      font-size: 14px;
      color: #888;
      margin-top: 12px;
      font-style: italic;
    }
    
    .upload-container {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .file-input {
      display: none;
    }
    
    .upload-btn {
      display: inline-block;
      background-color: #4a6cf7;
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    .upload-btn:hover {
      background-color: #3a5ce5;
    }
    
    .cropper-container-wrapper {
      height: 400px;
      margin-bottom: 20px;
      display: none;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .cropper-container {
      height: 100%;
      width: 100%;
    }
    
    .btn-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    .btn-primary {
      background-color: #4a6cf7;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #3a5ce5;
    }
    
    .btn-secondary {
      background-color: #e0e0e0;
      color: #333;
    }
    
    .btn-secondary:hover {
      background-color: #d0d0d0;
    }
    
    .preview-container {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    
    .preview-image {
      max-width: 100%;
      max-height: 300px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>è¡¨æƒ…åŒ…æ™ºèƒ½è£å‰ªå·¥å…·</h1>
    
    <div class="description">
      <p>ğŸ¯ ä¸“ä¸ºæŠ–éŸ³ã€å°çº¢ä¹¦è¯„è®ºåŒºè¡¨æƒ…åŒ…è®¾è®¡çš„æ™ºèƒ½è£å‰ªå·¥å…·</p>
      <p>ğŸ¤– è‡ªåŠ¨è¯†åˆ«å¹¶å»é™¤å›¾ç‰‡å‘¨å›´çš„é»‘è¾¹ã€ç™½è¾¹ï¼Œç²¾å‡†ä¿ç•™è¡¨æƒ…åŒ…å†…å®¹</p>
      <p class="tips">ğŸ’¡ æ”¯æŒå„ç§æ ¼å¼çš„è¡¨æƒ…åŒ…å›¾ç‰‡ï¼Œä¸Šä¼ åè‡ªåŠ¨æ™ºèƒ½åˆ†æè£å‰ª</p>
    </div>
    
    <div class="upload-container">
      <input type="file" id="file-input" class="file-input" accept="image/*">
      <label for="file-input" class="upload-btn">é€‰æ‹©è¡¨æƒ…åŒ…å›¾ç‰‡</label>
    </div>
    
    <div id="cropper-container-wrapper" class="cropper-container-wrapper">
      <div class="cropper-container"></div>
    </div>
    
    <div id="btn-container" class="btn-container" style="display: none;">
      <button id="auto-crop-btn" class="btn btn-secondary">æ™ºèƒ½è£å‰ª</button>
      <button id="crop-btn" class="btn btn-primary">ç¡®è®¤è£å‰ª</button>
      <button id="reset-btn" class="btn btn-secondary">é‡ç½®ç¼©æ”¾æ¯”ä¾‹</button>
      <button id="clear-btn" class="btn btn-secondary">é‡æ–°é€‰æ‹©å›¾ç‰‡</button>
    </div>
    
    <div id="preview-container" class="preview-container">
      <h3>è£å‰ªç»“æœ</h3>
      <img id="preview-image" class="preview-image">
      <div style="margin-top: 15px;">
        <a id="download-btn" class="btn btn-primary" download="cropped-image.png">ä¸‹è½½è£å‰ªç»“æœ</a>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const fileInput = document.getElementById('file-input');
      const cropperContainerWrapper = document.getElementById('cropper-container-wrapper');
      const cropperContainer = document.querySelector('.cropper-container');
      const btnContainer = document.getElementById('btn-container');
      const cropBtn = document.getElementById('crop-btn');
      const resetBtn = document.getElementById('reset-btn');
      const autoCropBtn = document.getElementById('auto-crop-btn');
      const clearBtn = document.getElementById('clear-btn');
      const previewContainer = document.getElementById('preview-container');
      const previewImage = document.getElementById('preview-image');
      const downloadBtn = document.getElementById('download-btn');
      
      let cropper = null;
      let image = null;
      
      // æ™ºèƒ½æ»šåŠ¨åˆ°æŒ‰é’®åŒºåŸŸçš„å‡½æ•°
      function smoothScrollToButtons(delay = 200) {
        setTimeout(() => {
          // è®¡ç®—æŒ‰é’®å®¹å™¨çš„ä½ç½®
          const btnRect = btnContainer.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          
          // å¦‚æœæŒ‰é’®ä¸å®Œå…¨å¯è§ï¼Œåˆ™æ»šåŠ¨
          if (btnRect.bottom > windowHeight * 0.9) {
            // æ»šåŠ¨åˆ°èƒ½çœ‹åˆ°æŒ‰é’®çš„ä½ç½®ï¼Œç•™å‡ºä¸€äº›åº•éƒ¨ç©ºé—´
            const targetScroll = window.scrollY + btnRect.bottom - windowHeight + 80;
            
            window.scrollTo({
              top: Math.max(0, targetScroll),
              behavior: 'smooth'
            });
          }
        }, delay);
      }
      
      // æ–‡ä»¶ä¸Šä¼ å¤„ç†
      fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        // é‡ç½®
        if (cropper) {
          cropper.destroy();
          cropper = null;
          cropperContainer.innerHTML = '';
        }
        
        // æ˜¾ç¤ºè£å‰ªåŒºåŸŸ
        cropperContainerWrapper.style.display = 'block';
        btnContainer.style.display = 'flex';
        previewContainer.style.display = 'none';
        
        // æ™ºèƒ½æ»šåŠ¨åˆ°æŒ‰é’®åŒºåŸŸ
        smoothScrollToButtons(200);
        
        // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
        image = new Image();
        const reader = new FileReader();
        
        reader.onload = function(e) {
          image.src = e.target.result;
          image.alt = 'ä¸Šä¼ çš„å›¾ç‰‡';
          cropperContainer.appendChild(image);
          
          // åˆå§‹åŒ–è£å‰ªå™¨
          cropper = new Cropper(image, {
            viewMode: 1,
            aspectRatio: NaN,
            autoCropArea: 0.8,
            background: true,
            ready: function() {
              // å›¾ç‰‡åŠ è½½å®Œæˆåè‡ªåŠ¨æ‰§è¡Œæ™ºèƒ½è£å‰ª
              setTimeout(() => {
                if (cropper) {
                  performSmartCrop();
                }
              }, 300);
              
              // è£å‰ªå™¨åˆå§‹åŒ–å®Œæˆåï¼Œç¡®ä¿æ»šåŠ¨åˆ°æŒ‰é’®åŒºåŸŸ
              smoothScrollToButtons(800);
            }
          });
        };
        
        reader.readAsDataURL(file);
      });
      
      // æ‰‹åŠ¨è£å‰ªå¤„ç†
      cropBtn.addEventListener('click', function() {
        if (!cropper) return;
        
        const canvas = cropper.getCroppedCanvas({
          fillColor: '#fff'
        });
        
        const dataUrl = canvas.toDataURL('image/png');
        previewImage.src = dataUrl;
        downloadBtn.href = dataUrl;
        
        previewContainer.style.display = 'block';
      });
      
      // é‡ç½®ç¼©æ”¾æ¯”ä¾‹ - é‡æ–°å¤„ç†å½“å‰å›¾ç‰‡
      resetBtn.addEventListener('click', function() {
        if (!cropper || !image) return;
        
        // ä¿å­˜å½“å‰å›¾ç‰‡æº
        const currentImageSrc = image.src;
        
        // é”€æ¯å½“å‰è£å‰ªå™¨
        cropper.destroy();
        cropper = null;
        cropperContainer.innerHTML = '';
        
        // éšè—é¢„è§ˆåŒºåŸŸ
        previewContainer.style.display = 'none';
        
        // é‡æ–°åˆ›å»ºå›¾ç‰‡å…ƒç´ å’Œè£å‰ªå™¨
        image = new Image();
        image.src = currentImageSrc;
        image.alt = 'ä¸Šä¼ çš„å›¾ç‰‡';
        cropperContainer.appendChild(image);
        
        // é‡æ–°åˆå§‹åŒ–è£å‰ªå™¨
        cropper = new Cropper(image, {
          viewMode: 1,
          aspectRatio: NaN,
          autoCropArea: 0.8,
          background: true,
          ready: function() {
            // é‡æ–°æ‰§è¡Œæ™ºèƒ½è£å‰ª
            setTimeout(() => {
              if (cropper) {
                performSmartCrop();
              }
            }, 300);
            
            // é‡ç½®åä¹Ÿæ»šåŠ¨åˆ°æŒ‰é’®åŒºåŸŸ
            smoothScrollToButtons(800);
          }
        });
        
        console.log('é‡ç½®ç¼©æ”¾æ¯”ä¾‹ï¼Œé‡æ–°å¤„ç†å›¾ç‰‡');
      });
      
      // æ™ºèƒ½è£å‰ªæŒ‰é’®
      autoCropBtn.addEventListener('click', function() {
        if (!cropper) return;
        performSmartCrop();
      });
      
      // é‡æ–°é€‰æ‹©å›¾ç‰‡ - å®Œå…¨æ¸…ç©º
      clearBtn.addEventListener('click', function() {
        fileInput.value = '';
        if (cropper) {
          cropper.destroy();
          cropper = null;
          cropperContainer.innerHTML = '';
        }
        image = null;
        cropperContainerWrapper.style.display = 'none';
        btnContainer.style.display = 'none';
        previewContainer.style.display = 'none';
        
        console.log('æ¸…ç©ºæ‰€æœ‰å†…å®¹ï¼Œå¯ä»¥é‡æ–°é€‰æ‹©å›¾ç‰‡');
      });
      
      // æ™ºèƒ½è£å‰ªä¸»å‡½æ•°
      function performSmartCrop() {
        console.log("å¼€å§‹æ™ºèƒ½è£å‰ªåˆ†æ...");
        
        try {
          const canvasData = cropper.getCanvasData();
          const imageElement = cropper.image;
          
          // åˆ›å»ºåˆ†æç”¨çš„ä¸´æ—¶ç”»å¸ƒ
          const tempCanvas = document.createElement('canvas');
          const ctx = tempCanvas.getContext('2d');
          
          // ä½¿ç”¨é€‚ä¸­çš„åˆ†è¾¨ç‡è¿›è¡Œåˆ†æ
          const analysisWidth = 200;
          const analysisHeight = Math.round(analysisWidth * imageElement.naturalHeight / imageElement.naturalWidth);
          
          tempCanvas.width = analysisWidth;
          tempCanvas.height = analysisHeight;
          
          // ç»˜åˆ¶å›¾åƒåˆ°åˆ†æç”»å¸ƒ
          ctx.drawImage(imageElement, 0, 0, analysisWidth, analysisHeight);
          const imageData = ctx.getImageData(0, 0, analysisWidth, analysisHeight);
          
          // åˆ†æèƒŒæ™¯ç±»å‹
          const backgroundType = analyzeBackgroundType(imageData.data, analysisWidth, analysisHeight);
          console.log('æ£€æµ‹åˆ°èƒŒæ™¯ç±»å‹:', backgroundType);
          
          // è®¡ç®—å†…å®¹é‡å¿ƒ
          const contentCenter = calculateContentCenter(imageData.data, analysisWidth, analysisHeight, backgroundType);
          console.log('å†…å®¹é‡å¿ƒ:', contentCenter);
          
          // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼
          const thresholds = calculateAdaptiveThresholds(imageData.data, analysisWidth, analysisHeight, backgroundType);
          console.log('è‡ªé€‚åº”é˜ˆå€¼:', thresholds);
          
          // æ£€æµ‹æœ€ä¼˜è¾¹ç•Œ
          const boundaries = detectOptimalBoundaries(imageData.data, analysisWidth, analysisHeight, contentCenter, thresholds, backgroundType);
          console.log('æ£€æµ‹åˆ°çš„è¾¹ç•Œ:', boundaries);
          
          // åº”ç”¨è£å‰ªåŒºåŸŸ
          applyCropBoundaries(cropper, imageElement, canvasData, analysisWidth, analysisHeight, boundaries);
          
        } catch (error) {
          console.error('æ™ºèƒ½è£å‰ªå‡ºé”™:', error);
          // é™çº§åˆ°åŸºç¡€è£å‰ª
          basicCrop();
        }
      }
      
      // åˆ†æèƒŒæ™¯ç±»å‹
      function analyzeBackgroundType(imageData, width, height) {
        const sampleSize = Math.min(width, height) * 0.1;
        const samples = [];
        
        // é‡‡æ ·å››ä¸ªè§’è½å’Œè¾¹ç¼˜ä¸­å¿ƒ
        const samplePoints = [
          // å››ä¸ªè§’è½
          {x: 0, y: 0}, {x: width-1, y: 0}, 
          {x: 0, y: height-1}, {x: width-1, y: height-1},
          // è¾¹ç¼˜ä¸­å¿ƒ
          {x: width/2, y: 0}, {x: width/2, y: height-1},
          {x: 0, y: height/2}, {x: width-1, y: height/2}
        ];
        
        for (const point of samplePoints) {
          const x = Math.floor(point.x);
          const y = Math.floor(point.y);
          const idx = (y * width + x) * 4;
          const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
          samples.push(brightness);
        }
        
        const avgBrightness = samples.reduce((a, b) => a + b, 0) / samples.length;
        const darkSamples = samples.filter(b => b < 50).length;
        const lightSamples = samples.filter(b => b > 200).length;
        
        if (darkSamples > lightSamples || avgBrightness < 80) {
          return 'dark';
        } else {
          return 'light';
        }
      }
      
      // è®¡ç®—å†…å®¹é‡å¿ƒ
      function calculateContentCenter(imageData, width, height, backgroundType) {
        let totalWeight = 0;
        let weightedX = 0;
        let weightedY = 0;
        
        const isDark = backgroundType === 'dark';
        const threshold = isDark ? 60 : 180;
        
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
            
            let weight = 0;
            if (isDark) {
              // æš—èƒŒæ™¯ï¼šäº®åº¦è¶Šé«˜æƒé‡è¶Šå¤§
              if (brightness > threshold) {
                weight = (brightness - threshold) / (255 - threshold);
              }
            } else {
              // äº®èƒŒæ™¯ï¼šäº®åº¦è¶Šä½æƒé‡è¶Šå¤§
              if (brightness < threshold) {
                weight = (threshold - brightness) / threshold;
              }
            }
            
            if (weight > 0) {
              totalWeight += weight;
              weightedX += x * weight;
              weightedY += y * weight;
            }
          }
        }
        
        if (totalWeight > 0) {
          return {
            x: Math.round(weightedX / totalWeight),
            y: Math.round(weightedY / totalWeight)
          };
        } else {
          return {
            x: Math.floor(width / 2),
            y: Math.floor(height / 2)
          };
        }
      }
      
      // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼
      function calculateAdaptiveThresholds(imageData, width, height, backgroundType) {
        const histogram = new Array(256).fill(0);
        
        // æ„å»ºäº®åº¦ç›´æ–¹å›¾
        for (let i = 0; i < width * height; i++) {
          const idx = i * 4;
          const brightness = Math.round((imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3);
          histogram[brightness]++;
        }
        
        // æ‰¾åˆ°ä¸»è¦å³°å€¼
        const isDark = backgroundType === 'dark';
        let backgroundPeak = 0;
        let contentPeak = 255;
        let maxBackgroundCount = 0;
        let maxContentCount = 0;
        
        if (isDark) {
          // æš—èƒŒæ™¯
          for (let i = 0; i < 80; i++) {
            if (histogram[i] > maxBackgroundCount) {
              maxBackgroundCount = histogram[i];
              backgroundPeak = i;
            }
          }
          for (let i = 80; i < 256; i++) {
            if (histogram[i] > maxContentCount) {
              maxContentCount = histogram[i];
              contentPeak = i;
            }
          }
        } else {
          // äº®èƒŒæ™¯
          for (let i = 180; i < 256; i++) {
            if (histogram[i] > maxBackgroundCount) {
              maxBackgroundCount = histogram[i];
              backgroundPeak = i;
            }
          }
          for (let i = 0; i < 180; i++) {
            if (histogram[i] > maxContentCount) {
              maxContentCount = histogram[i];
              contentPeak = i;
            }
          }
        }
        
        const backgroundThreshold = isDark ? 
          Math.min(backgroundPeak + 30, 70) : 
          Math.max(backgroundPeak - 30, 190);
          
        const contentThreshold = isDark ?
          Math.max(contentPeak - 40, backgroundThreshold + 25) :
          Math.min(contentPeak + 40, backgroundThreshold - 25);
        
        return {
          background: backgroundThreshold,
          content: contentThreshold,
          isDark: isDark
        };
      }
      
      // æ£€æµ‹æœ€ä¼˜è¾¹ç•Œ
      function detectOptimalBoundaries(imageData, width, height, center, thresholds, backgroundType) {
        const isDark = thresholds.isDark;
        const bgThreshold = thresholds.background;
        const contentThreshold = thresholds.content;
        
        // ä»ä¸­å¿ƒå‘å››ä¸ªæ–¹å‘æœç´¢è¾¹ç•Œ
        const boundaries = {
          top: 0,
          bottom: height - 1,
          left: 0,
          right: width - 1
        };
        
        // å‘ä¸Šæœç´¢
        for (let y = center.y; y >= 0; y--) {
          let backgroundPixels = 0;
          const checkWidth = Math.min(width, Math.max(30, width * 0.8));
          const startX = Math.floor((width - checkWidth) / 2);
          
          for (let x = startX; x < startX + checkWidth; x++) {
            const idx = (y * width + x) * 4;
            const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
            
            if (isDark ? brightness < bgThreshold : brightness > bgThreshold) {
              backgroundPixels++;
            }
          }
          
          if (backgroundPixels > checkWidth * 0.8) {
            boundaries.top = Math.min(y + 2, center.y);
            break;
          }
        }
        
        // å‘ä¸‹æœç´¢
        for (let y = center.y; y < height; y++) {
          let backgroundPixels = 0;
          const checkWidth = Math.min(width, Math.max(30, width * 0.8));
          const startX = Math.floor((width - checkWidth) / 2);
          
          for (let x = startX; x < startX + checkWidth; x++) {
            const idx = (y * width + x) * 4;
            const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
            
            if (isDark ? brightness < bgThreshold : brightness > bgThreshold) {
              backgroundPixels++;
            }
          }
          
          if (backgroundPixels > checkWidth * 0.8) {
            boundaries.bottom = Math.max(y - 2, center.y);
            break;
          }
        }
        
        // å‘å·¦æœç´¢
        for (let x = center.x; x >= 0; x--) {
          let backgroundPixels = 0;
          const checkHeight = Math.min(height, Math.max(30, height * 0.8));
          const startY = Math.floor((height - checkHeight) / 2);
          
          for (let y = startY; y < startY + checkHeight; y++) {
            const idx = (y * width + x) * 4;
            const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
            
            if (isDark ? brightness < bgThreshold : brightness > bgThreshold) {
              backgroundPixels++;
            }
          }
          
          if (backgroundPixels > checkHeight * 0.8) {
            boundaries.left = Math.min(x + 2, center.x);
            break;
          }
        }
        
        // å‘å³æœç´¢
        for (let x = center.x; x < width; x++) {
          let backgroundPixels = 0;
          const checkHeight = Math.min(height, Math.max(30, height * 0.8));
          const startY = Math.floor((height - checkHeight) / 2);
          
          for (let y = startY; y < startY + checkHeight; y++) {
            const idx = (y * width + x) * 4;
            const brightness = (imageData[idx] + imageData[idx + 1] + imageData[idx + 2]) / 3;
            
            if (isDark ? brightness < bgThreshold : brightness > bgThreshold) {
              backgroundPixels++;
            }
          }
          
          if (backgroundPixels > checkHeight * 0.8) {
            boundaries.right = Math.max(x - 2, center.x);
            break;
          }
        }
        
        return boundaries;
      }
      
      // åº”ç”¨è£å‰ªè¾¹ç•Œ
      function applyCropBoundaries(cropper, imageElement, canvasData, analysisWidth, analysisHeight, boundaries) {
        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
        const scaleX = imageElement.naturalWidth / analysisWidth;
        const scaleY = imageElement.naturalHeight / analysisHeight;
        
        // è½¬æ¢åˆ°åŸå§‹å›¾åƒåæ ‡
        const originalBounds = {
          left: Math.round(boundaries.left * scaleX),
          top: Math.round(boundaries.top * scaleY),
          width: Math.round((boundaries.right - boundaries.left) * scaleX),
          height: Math.round((boundaries.bottom - boundaries.top) * scaleY)
        };
        
        // è½¬æ¢åˆ°canvasåæ ‡
        const canvasScaleX = canvasData.width / imageElement.naturalWidth;
        const canvasScaleY = canvasData.height / imageElement.naturalHeight;
        
        const cropBox = {
          left: canvasData.left + originalBounds.left * canvasScaleX,
          top: canvasData.top + originalBounds.top * canvasScaleY,
          width: originalBounds.width * canvasScaleX,
          height: originalBounds.height * canvasScaleY
        };
        
        // éªŒè¯è¾¹ç•Œåˆç†æ€§
        if (cropBox.width > 10 && cropBox.height > 10 && 
            cropBox.left >= canvasData.left && cropBox.top >= canvasData.top &&
            cropBox.left + cropBox.width <= canvasData.left + canvasData.width &&
            cropBox.top + cropBox.height <= canvasData.top + canvasData.height) {
          
          console.log('åº”ç”¨æ™ºèƒ½è£å‰ªè¾¹ç•Œ:', cropBox);
          cropper.setCropBoxData(cropBox);
        } else {
          console.log('è¾¹ç•Œæ— æ•ˆï¼Œä½¿ç”¨åŸºç¡€è£å‰ª');
          basicCrop();
        }
      }
      
      // åŸºç¡€è£å‰ªï¼ˆé™çº§æ–¹æ¡ˆï¼‰
      function basicCrop() {
        if (!cropper) return;
        
        const containerData = cropper.getContainerData();
        const imageData = cropper.getImageData();
        
        // ä½¿ç”¨80%çš„å›¾åƒåŒºåŸŸä½œä¸ºåŸºç¡€è£å‰ª
        const cropWidth = imageData.width * 0.8;
        const cropHeight = imageData.height * 0.8;
        const cropLeft = imageData.left + (imageData.width - cropWidth) / 2;
        const cropTop = imageData.top + (imageData.height - cropHeight) / 2;
        
        cropper.setCropBoxData({
          left: cropLeft,
          top: cropTop,
          width: cropWidth,
          height: cropHeight
        });
        
        console.log('åº”ç”¨åŸºç¡€è£å‰ª');
      }
    });
  </script>
</body>
</html> 